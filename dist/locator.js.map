{"version":3,"file":"locator.js","sources":["../src/locator/index.ts"],"sourcesContent":["import { BitMatrix } from \"../BitMatrix\";\n\nconst MAX_FINDERPATTERNS_TO_SEARCH = 5;\nconst MIN_QUAD_RATIO = 0.5;\nconst MAX_QUAD_RATIO = 1.5;\n\nexport interface Point {\n  x: number;\n  y: number;\n}\n\nexport interface QRLocation {\n  topRight: Point;\n  bottomLeft: Point;\n  topLeft: Point;\n  alignmentPattern: Point;\n  dimension: number;\n}\n\nconst distance = (a: Point, b: Point) =>\n  Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);\n\nfunction sum(values: number[]) {\n  return values.reduce((a, b) => a + b);\n}\n\n// Takes three finder patterns and organizes them into topLeft, topRight, etc\nfunction reorderFinderPatterns(\n  pattern1: Point,\n  pattern2: Point,\n  pattern3: Point,\n) {\n  // Find distances between pattern centers\n  const oneTwoDistance = distance(pattern1, pattern2);\n  const twoThreeDistance = distance(pattern2, pattern3);\n  const oneThreeDistance = distance(pattern1, pattern3);\n\n  let bottomLeft: Point;\n  let topLeft: Point;\n  let topRight: Point;\n\n  // Assume one closest to other two is B; A and C will just be guesses at first\n  if (\n    twoThreeDistance >= oneTwoDistance &&\n    twoThreeDistance >= oneThreeDistance\n  ) {\n    [bottomLeft, topLeft, topRight] = [pattern2, pattern1, pattern3];\n  } else if (\n    oneThreeDistance >= twoThreeDistance &&\n    oneThreeDistance >= oneTwoDistance\n  ) {\n    [bottomLeft, topLeft, topRight] = [pattern1, pattern2, pattern3];\n  } else {\n    [bottomLeft, topLeft, topRight] = [pattern1, pattern3, pattern2];\n  }\n\n  // Use cross product to figure out whether bottomLeft (A) and topRight (C) are correct or flipped in relation to topLeft (B)\n  // This asks whether BC x BA has a positive z component, which is the arrangement we want. If it's negative, then\n  // we've got it flipped around and should swap topRight and bottomLeft.\n  if (\n    (topRight.x - topLeft.x) * (bottomLeft.y - topLeft.y) -\n      (topRight.y - topLeft.y) * (bottomLeft.x - topLeft.x) <\n    0\n  ) {\n    [bottomLeft, topRight] = [topRight, bottomLeft];\n  }\n\n  return { bottomLeft, topLeft, topRight };\n}\n\n// Computes the dimension (number of modules on a side) of the QR Code based on the position of the finder patterns\nfunction computeDimension(\n  topLeft: Point,\n  topRight: Point,\n  bottomLeft: Point,\n  matrix: BitMatrix,\n) {\n  const moduleSize =\n    (sum(countBlackWhiteRun(topLeft, bottomLeft, matrix, 5)) / 7 + // Divide by 7 since the ratio is 1:1:3:1:1\n      sum(countBlackWhiteRun(topLeft, topRight, matrix, 5)) / 7 +\n      sum(countBlackWhiteRun(bottomLeft, topLeft, matrix, 5)) / 7 +\n      sum(countBlackWhiteRun(topRight, topLeft, matrix, 5)) / 7) /\n    4;\n\n  if (moduleSize < 1) {\n    throw new Error(\"Invalid module size\");\n  }\n\n  const topDimension = Math.round(distance(topLeft, topRight) / moduleSize);\n  const sideDimension = Math.round(distance(topLeft, bottomLeft) / moduleSize);\n  let dimension = Math.floor((topDimension + sideDimension) / 2) + 7;\n  switch (dimension % 4) {\n    case 0:\n      dimension++;\n      break;\n    case 2:\n      dimension--;\n      break;\n  }\n  return { dimension, moduleSize };\n}\n\n// Takes an origin point and an end point and counts the sizes of the black white run from the origin towards the end point.\n// Returns an array of elements, representing the pixel size of the black white run.\n// Uses a variant of http://en.wikipedia.org/wiki/Bresenham's_line_algorithm\nfunction countBlackWhiteRunTowardsPoint(\n  origin: Point,\n  end: Point,\n  matrix: BitMatrix,\n  length: number,\n) {\n  const switchPoints: Point[] = [\n    { x: Math.floor(origin.x), y: Math.floor(origin.y) },\n  ];\n  const steep = Math.abs(end.y - origin.y) > Math.abs(end.x - origin.x);\n\n  let fromX: number;\n  let fromY: number;\n  let toX: number;\n  let toY: number;\n  if (steep) {\n    fromX = Math.floor(origin.y);\n    fromY = Math.floor(origin.x);\n    toX = Math.floor(end.y);\n    toY = Math.floor(end.x);\n  } else {\n    fromX = Math.floor(origin.x);\n    fromY = Math.floor(origin.y);\n    toX = Math.floor(end.x);\n    toY = Math.floor(end.y);\n  }\n\n  const dx = Math.abs(toX - fromX);\n  const dy = Math.abs(toY - fromY);\n  let error = Math.floor(-dx / 2);\n  const xStep = fromX < toX ? 1 : -1;\n  const yStep = fromY < toY ? 1 : -1;\n\n  let currentPixel = true;\n  // Loop up until x == toX, but not beyond\n  for (let x = fromX, y = fromY; x !== toX + xStep; x += xStep) {\n    // Does current pixel mean we have moved white to black or vice versa?\n    // Scanning black in state 0,2 and white in state 1, so if we find the wrong\n    // color, advance to next state or end if we are in state 2 already\n    const realX = steep ? y : x;\n    const realY = steep ? x : y;\n    if (matrix.get(realX, realY) !== currentPixel) {\n      currentPixel = !currentPixel;\n      switchPoints.push({ x: realX, y: realY });\n      if (switchPoints.length === length + 1) {\n        break;\n      }\n    }\n    error += dy;\n    if (error > 0) {\n      if (y === toY) {\n        break;\n      }\n      y += yStep;\n      error -= dx;\n    }\n  }\n  const distances: number[] = [];\n  for (let i = 0; i < length; i++) {\n    if (switchPoints[i] && switchPoints[i + 1]) {\n      distances.push(distance(switchPoints[i], switchPoints[i + 1]));\n    } else {\n      distances.push(0);\n    }\n  }\n  return distances;\n}\n\n// Takes an origin point and an end point and counts the sizes of the black white run in the origin point\n// along the line that intersects with the end point. Returns an array of elements, representing the pixel sizes\n// of the black white run. Takes a length which represents the number of switches from black to white to look for.\nfunction countBlackWhiteRun(\n  origin: Point,\n  end: Point,\n  matrix: BitMatrix,\n  length: number,\n) {\n  const rise = end.y - origin.y;\n  const run = end.x - origin.x;\n\n  const towardsEnd = countBlackWhiteRunTowardsPoint(\n    origin,\n    end,\n    matrix,\n    Math.ceil(length / 2),\n  );\n  const awayFromEnd = countBlackWhiteRunTowardsPoint(\n    origin,\n    { x: origin.x - run, y: origin.y - rise },\n    matrix,\n    Math.ceil(length / 2),\n  );\n\n  const middleValue = towardsEnd.shift() + awayFromEnd.shift() - 1; // Substract one so we don't double count a pixel\n  return awayFromEnd.concat(middleValue).concat(...towardsEnd);\n}\n\n// Takes in a black white run and an array of expected ratios. Returns the average size of the run as well as the \"error\" -\n// that is the amount the run diverges from the expected ratio\nfunction scoreBlackWhiteRun(sequence: number[], ratios: number[]) {\n  const averageSize = sum(sequence) / sum(ratios);\n  let error = 0;\n  ratios.forEach((ratio, i) => {\n    error += (sequence[i] - ratio * averageSize) ** 2;\n  });\n\n  return { averageSize, error };\n}\n\n// Takes an X,Y point and an array of sizes and scores the point against those ratios.\n// For example for a finder pattern takes the ratio list of 1:1:3:1:1 and checks horizontal, vertical and diagonal ratios\n// against that.\nfunction scorePattern(point: Point, ratios: number[], matrix: BitMatrix) {\n  try {\n    const horizontalRun = countBlackWhiteRun(\n      point,\n      { x: -1, y: point.y },\n      matrix,\n      ratios.length,\n    );\n    const verticalRun = countBlackWhiteRun(\n      point,\n      { x: point.x, y: -1 },\n      matrix,\n      ratios.length,\n    );\n\n    const topLeftPoint = {\n      x: Math.max(0, point.x - point.y) - 1,\n      y: Math.max(0, point.y - point.x) - 1,\n    };\n    const topLeftBottomRightRun = countBlackWhiteRun(\n      point,\n      topLeftPoint,\n      matrix,\n      ratios.length,\n    );\n\n    const bottomLeftPoint = {\n      x: Math.min(matrix.width, point.x + point.y) + 1,\n      y: Math.min(matrix.height, point.y + point.x) + 1,\n    };\n    const bottomLeftTopRightRun = countBlackWhiteRun(\n      point,\n      bottomLeftPoint,\n      matrix,\n      ratios.length,\n    );\n\n    const horzError = scoreBlackWhiteRun(horizontalRun, ratios);\n    const vertError = scoreBlackWhiteRun(verticalRun, ratios);\n    const diagDownError = scoreBlackWhiteRun(topLeftBottomRightRun, ratios);\n    const diagUpError = scoreBlackWhiteRun(bottomLeftTopRightRun, ratios);\n\n    const ratioError = Math.sqrt(\n      horzError.error * horzError.error +\n        vertError.error * vertError.error +\n        diagDownError.error * diagDownError.error +\n        diagUpError.error * diagUpError.error,\n    );\n\n    const avgSize =\n      (horzError.averageSize +\n        vertError.averageSize +\n        diagDownError.averageSize +\n        diagUpError.averageSize) /\n      4;\n\n    const sizeError =\n      ((horzError.averageSize - avgSize) ** 2 +\n        (vertError.averageSize - avgSize) ** 2 +\n        (diagDownError.averageSize - avgSize) ** 2 +\n        (diagUpError.averageSize - avgSize) ** 2) /\n      avgSize;\n    return ratioError + sizeError;\n  } catch {\n    return Infinity;\n  }\n}\n\nfunction recenterLocation(matrix: BitMatrix, p: Point): Point {\n  let leftX = Math.round(p.x);\n  while (matrix.get(leftX, Math.round(p.y))) {\n    leftX--;\n  }\n  let rightX = Math.round(p.x);\n  while (matrix.get(rightX, Math.round(p.y))) {\n    rightX++;\n  }\n  const x = (leftX + rightX) / 2;\n\n  let topY = Math.round(p.y);\n  while (matrix.get(Math.round(x), topY)) {\n    topY--;\n  }\n  let bottomY = Math.round(p.y);\n  while (matrix.get(Math.round(x), bottomY)) {\n    bottomY++;\n  }\n  const y = (topY + bottomY) / 2;\n\n  return { x, y };\n}\n\ninterface Quad {\n  top: {\n    startX: number;\n    endX: number;\n    y: number;\n  };\n  bottom: {\n    startX: number;\n    endX: number;\n    y: number;\n  };\n}\n\nexport function locate(matrix: BitMatrix): QRLocation[] {\n  const finderPatternQuads: Quad[] = [];\n  let activeFinderPatternQuads: Quad[] = [];\n  const alignmentPatternQuads: Quad[] = [];\n  let activeAlignmentPatternQuads: Quad[] = [];\n\n  for (let y = 0; y <= matrix.height; y++) {\n    let length = 0;\n    let lastBit = false;\n    let scans = [0, 0, 0, 0, 0];\n\n    for (let x = -1; x <= matrix.width; x++) {\n      const v = matrix.get(x, y);\n      if (v === lastBit) {\n        length++;\n      } else {\n        scans = [scans[1], scans[2], scans[3], scans[4], length];\n        length = 1;\n        lastBit = v;\n\n        // Do the last 5 color changes ~ match the expected ratio for a finder pattern? 1:1:3:1:1 of b:w:b:w:b\n        const averageFinderPatternBlocksize = sum(scans) / 7;\n        const validFinderPattern =\n          Math.abs(scans[0] - averageFinderPatternBlocksize) <\n            averageFinderPatternBlocksize &&\n          Math.abs(scans[1] - averageFinderPatternBlocksize) <\n            averageFinderPatternBlocksize &&\n          Math.abs(scans[2] - 3 * averageFinderPatternBlocksize) <\n            3 * averageFinderPatternBlocksize &&\n          Math.abs(scans[3] - averageFinderPatternBlocksize) <\n            averageFinderPatternBlocksize &&\n          Math.abs(scans[4] - averageFinderPatternBlocksize) <\n            averageFinderPatternBlocksize &&\n          !v; // And make sure the current pixel is white since finder patterns are bordered in white\n\n        // Do the last 3 color changes ~ match the expected ratio for an alignment pattern? 1:1:1 of w:b:w\n        const averageAlignmentPatternBlocksize = sum(scans.slice(-3)) / 3;\n        const validAlignmentPattern =\n          Math.abs(scans[2] - averageAlignmentPatternBlocksize) <\n            averageAlignmentPatternBlocksize &&\n          Math.abs(scans[3] - averageAlignmentPatternBlocksize) <\n            averageAlignmentPatternBlocksize &&\n          Math.abs(scans[4] - averageAlignmentPatternBlocksize) <\n            averageAlignmentPatternBlocksize &&\n          v; // Is the current pixel black since alignment patterns are bordered in black\n\n        if (validFinderPattern) {\n          // Compute the start and end x values of the large center black square\n          const endX = x - scans[3] - scans[4];\n          const startX = endX - scans[2];\n\n          const line = { startX, endX, y };\n          // Is there a quad directly above the current spot? If so, extend it with the new line. Otherwise, create a new quad with\n          // that line as the starting point.\n          const matchingQuads = activeFinderPatternQuads.filter(\n            (q) =>\n              (startX >= q.bottom.startX && startX <= q.bottom.endX) ||\n              (endX >= q.bottom.startX && startX <= q.bottom.endX) ||\n              (startX <= q.bottom.startX &&\n                endX >= q.bottom.endX &&\n                scans[2] / (q.bottom.endX - q.bottom.startX) < MAX_QUAD_RATIO &&\n                scans[2] / (q.bottom.endX - q.bottom.startX) > MIN_QUAD_RATIO),\n          );\n          if (matchingQuads.length > 0) {\n            matchingQuads[0].bottom = line;\n          } else {\n            activeFinderPatternQuads.push({ top: line, bottom: line });\n          }\n        }\n        if (validAlignmentPattern) {\n          // Compute the start and end x values of the center black square\n          const endX = x - scans[4];\n          const startX = endX - scans[3];\n\n          const line = { startX, y, endX };\n          // Is there a quad directly above the current spot? If so, extend it with the new line. Otherwise, create a new quad with\n          // that line as the starting point.\n          const matchingQuads = activeAlignmentPatternQuads.filter(\n            (q) =>\n              (startX >= q.bottom.startX && startX <= q.bottom.endX) ||\n              (endX >= q.bottom.startX && startX <= q.bottom.endX) ||\n              (startX <= q.bottom.startX &&\n                endX >= q.bottom.endX &&\n                scans[2] / (q.bottom.endX - q.bottom.startX) < MAX_QUAD_RATIO &&\n                scans[2] / (q.bottom.endX - q.bottom.startX) > MIN_QUAD_RATIO),\n          );\n          if (matchingQuads.length > 0) {\n            matchingQuads[0].bottom = line;\n          } else {\n            activeAlignmentPatternQuads.push({ top: line, bottom: line });\n          }\n        }\n      }\n    }\n    finderPatternQuads.push(\n      ...activeFinderPatternQuads.filter(\n        (q) => q.bottom.y !== y && q.bottom.y - q.top.y >= 2,\n      ),\n    );\n    activeFinderPatternQuads = activeFinderPatternQuads.filter(\n      (q) => q.bottom.y === y,\n    );\n\n    alignmentPatternQuads.push(\n      ...activeAlignmentPatternQuads.filter((q) => q.bottom.y !== y),\n    );\n    activeAlignmentPatternQuads = activeAlignmentPatternQuads.filter(\n      (q) => q.bottom.y === y,\n    );\n  }\n\n  finderPatternQuads.push(\n    ...activeFinderPatternQuads.filter((q) => q.bottom.y - q.top.y >= 2),\n  );\n  alignmentPatternQuads.push(...activeAlignmentPatternQuads);\n\n  // Refactored from cozmo/jsQR to (hopefully) circumvent an issue in Safari 13+ on both Mac and iOS (also including\n  // iOS Chrome and other Safari iOS derivatives). Safari was very occasionally and apparently not deterministically\n  // throwing a \"RangeError: Array size is not a small enough positive integer.\" exception seemingly within the second\n  // .map of the original code (here the second for-loop). This second .map contained a nested .map call over the same\n  // array instance which was the chained result from previous calls to .map, .filter and .sort which potentially caused\n  // this bug in Safari?\n  // Also see https://github.com/cozmo/jsQR/issues/157 and https://bugs.webkit.org/show_bug.cgi?id=211619#c3\n  const scoredFinderPatternPositions: Array<\n    Point & { size: number; score: number }\n  > = [];\n  for (const quad of finderPatternQuads) {\n    if (quad.bottom.y - quad.top.y < 2) {\n      // All quads must be at least 2px tall since the center square is larger than a block\n      continue;\n    }\n\n    // calculate quad center\n    const x =\n      (quad.top.startX +\n        quad.top.endX +\n        quad.bottom.startX +\n        quad.bottom.endX) /\n      4;\n    const y = (quad.top.y + quad.bottom.y + 1) / 2;\n    if (!matrix.get(Math.round(x), Math.round(y))) {\n      continue;\n    }\n\n    const lengths = [\n      quad.top.endX - quad.top.startX,\n      quad.bottom.endX - quad.bottom.startX,\n      quad.bottom.y - quad.top.y + 1,\n    ];\n    const size = sum(lengths) / lengths.length;\n    // Initial scoring of finder pattern quads by looking at their ratios, not taking into account position\n    const score = scorePattern(\n      { x: Math.round(x), y: Math.round(y) },\n      [1, 1, 3, 1, 1],\n      matrix,\n    );\n    scoredFinderPatternPositions.push({ score, x, y, size });\n  }\n  if (scoredFinderPatternPositions.length < 3) {\n    // A QR code has 3 finder patterns, therefore we need at least 3 candidates.\n    return null;\n  }\n  scoredFinderPatternPositions.sort((a, b) => a.score - b.score);\n\n  // Now take the top finder pattern options and try to find 2 other options with a similar size.\n  const finderPatternGroups: Array<{\n    points: [Point, Point, Point];\n    score: number;\n  }> = [];\n  for (\n    let i = 0;\n    i <\n    Math.min(scoredFinderPatternPositions.length, MAX_FINDERPATTERNS_TO_SEARCH);\n    ++i\n  ) {\n    const point = scoredFinderPatternPositions[i];\n    const otherPoints: typeof scoredFinderPatternPositions = [];\n\n    for (const otherPoint of scoredFinderPatternPositions) {\n      if (otherPoint === point) {\n        continue;\n      }\n      otherPoints.push({\n        ...otherPoint,\n        score:\n          otherPoint.score + (otherPoint.size - point.size) ** 2 / point.size, // score similarity of sizes\n      });\n    }\n    otherPoints.sort((a, b) => a.score - b.score);\n\n    finderPatternGroups.push({\n      points: [point, otherPoints[0], otherPoints[1]], // note that otherPoints.length >= 2 as scoredFinderPatternPositions.length >= 3\n      score: point.score + otherPoints[0].score + otherPoints[1].score, // total combined score of the three points in the group\n    });\n  }\n  finderPatternGroups.sort((a, b) => a.score - b.score);\n  const bestFinderPatternGroup = finderPatternGroups[0];\n\n  const { topRight, topLeft, bottomLeft } = reorderFinderPatterns(\n    ...bestFinderPatternGroup.points,\n  );\n  const alignment = findAlignmentPattern(\n    matrix,\n    alignmentPatternQuads,\n    topRight,\n    topLeft,\n    bottomLeft,\n  );\n  const result: QRLocation[] = [];\n  if (alignment) {\n    result.push({\n      alignmentPattern: {\n        x: alignment.alignmentPattern.x,\n        y: alignment.alignmentPattern.y,\n      },\n      bottomLeft: { x: bottomLeft.x, y: bottomLeft.y },\n      dimension: alignment.dimension,\n      topLeft: { x: topLeft.x, y: topLeft.y },\n      topRight: { x: topRight.x, y: topRight.y },\n    });\n  }\n\n  // We normally use the center of the quads as the location of the tracking points, which is optimal for most cases and will account\n  // for a skew in the image. However, In some cases, a slight skew might not be real and instead be caused by image compression\n  // errors and/or low resolution. For those cases, we'd be better off centering the point exactly in the middle of the black area. We\n  // compute and return the location data for the naively centered points as it is little additional work and allows for multiple\n  // attempts at decoding harder images.\n  const midTopRight = recenterLocation(matrix, topRight);\n  const midTopLeft = recenterLocation(matrix, topLeft);\n  const midBottomLeft = recenterLocation(matrix, bottomLeft);\n  const centeredAlignment = findAlignmentPattern(\n    matrix,\n    alignmentPatternQuads,\n    midTopRight,\n    midTopLeft,\n    midBottomLeft,\n  );\n  if (centeredAlignment) {\n    result.push({\n      alignmentPattern: {\n        x: centeredAlignment.alignmentPattern.x,\n        y: centeredAlignment.alignmentPattern.y,\n      },\n      bottomLeft: { x: midBottomLeft.x, y: midBottomLeft.y },\n      topLeft: { x: midTopLeft.x, y: midTopLeft.y },\n      topRight: { x: midTopRight.x, y: midTopRight.y },\n      dimension: centeredAlignment.dimension,\n    });\n  }\n\n  if (result.length === 0) {\n    return null;\n  }\n\n  return result;\n}\n\nfunction findAlignmentPattern(\n  matrix: BitMatrix,\n  alignmentPatternQuads: Quad[],\n  topRight: Point,\n  topLeft: Point,\n  bottomLeft: Point,\n) {\n  // Now that we've found the three finder patterns we can determine the blockSize and the size of the QR code.\n  // We'll use these to help find the alignment pattern but also later when we do the extraction.\n  let dimension: number;\n  let moduleSize: number;\n  try {\n    ({ dimension, moduleSize } = computeDimension(\n      topLeft,\n      topRight,\n      bottomLeft,\n      matrix,\n    ));\n  } catch (e) {\n    return null;\n  }\n\n  // Now find the alignment pattern\n  const bottomRightFinderPattern = {\n    // Best guess at where a bottomRight finder pattern would be\n    x: topRight.x - topLeft.x + bottomLeft.x,\n    y: topRight.y - topLeft.y + bottomLeft.y,\n  };\n  const modulesBetweenFinderPatterns =\n    (distance(topLeft, bottomLeft) + distance(topLeft, topRight)) /\n    2 /\n    moduleSize;\n  const correctionToTopLeft = 1 - 3 / modulesBetweenFinderPatterns;\n  const expectedAlignmentPattern = {\n    x:\n      topLeft.x +\n      correctionToTopLeft * (bottomRightFinderPattern.x - topLeft.x),\n    y:\n      topLeft.y +\n      correctionToTopLeft * (bottomRightFinderPattern.y - topLeft.y),\n  };\n\n  const alignmentPatterns = alignmentPatternQuads\n    .map((q) => {\n      const x =\n        (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4;\n      const y = (q.top.y + q.bottom.y + 1) / 2;\n      if (!matrix.get(Math.floor(x), Math.floor(y))) {\n        return;\n      }\n\n      const sizeScore = scorePattern(\n        { x: Math.floor(x), y: Math.floor(y) },\n        [1, 1, 1],\n        matrix,\n      );\n      const score = sizeScore + distance({ x, y }, expectedAlignmentPattern);\n      return { x, y, score };\n    })\n    .filter((v) => !!v)\n    .sort((a, b) => a.score - b.score);\n\n  // If there are less than 15 modules between finder patterns it's a version 1 QR code and as such has no alignmemnt pattern\n  // so we can only use our best guess.\n  const alignmentPattern =\n    modulesBetweenFinderPatterns >= 15 && alignmentPatterns.length\n      ? alignmentPatterns[0]\n      : expectedAlignmentPattern;\n\n  return { alignmentPattern, dimension };\n}\n"],"names":[],"mappings":"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"}